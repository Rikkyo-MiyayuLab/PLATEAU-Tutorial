# 2024/12/17 収録用カンペ

## 1. はじめに
本チュートリアルでは「AIに現実の都市空間での避難所の最適配置を考えさせる」というテーマで、強化学習AIモデルを用いて、制限時間内に避難率を最大化できる追加の避難所はどこか、ということを探索する避難シミュレーションの実装方法をハンズオン形式で解説します。

### 1-1. 強化学習とは？
強化学習とは機械学習、いわゆるAIの学習方法の１つで、通常の画像認識や音声認識のいわゆるデータ駆動型AIとは異なり、ゲーム空間などの仮想環境において、エージェント（とよばれるAI）が行動を選択し、その結果として得られる報酬（AIの選択の良し悪しを図る評価値）を最大化するように学習を行う機械学習アルゴリズムです。

強化学習は、AlphaGoなどのゲームAIや、自動運転車の制御など、状況に応じて最適な行動を選択する必要がある問題に適しています。

### 1-2. PLATEAU × 強化学習を使うとできること
特に、強化学習は仮想環境を活用して試行錯誤を繰り返しながら学習を進めるため、3D都市モデルであるPLATEAUとの親和性が高いです。PLATEAUは、日本の都市を詳細に再現した3D空間データを提供しており、このデータをシミュレーション環境として活用することで、現実世界に近い条件でAIエージェントを訓練できます。

例えば、PLATEAUを使用すれば、自動運転車の都市内移動や災害時の避難誘導シミュレーションなど、複雑な都市環境における最適な行動選択を学習することが可能です。さらに、現実の都市空間とデータの整合性が高いため、強化学習で得られた成果を現実世界に適用する際のギャップを縮小できるというメリットがあります。

また、PLATEAUは多様な都市データ（建物、道路、地形、地下構造物など）を統合しているため、強化学習の訓練に必要な環境パラメータを自由に設定できます。これにより、単に仮想環境内の最適行動を学習するだけでなく、都市設計や政策のシミュレーション、さらにはスマートシティの実現に向けた革新的な技術開発に貢献する可能性があります。

### 1-3. 制作物の概要
本チュートリアルではPLATEAU SDK for UnityとUnityの強化学習フレームワークであるML-Agentsを使った、避難所最適配置のシミュレーションの実装を行います。

PLATEAUで提供されている3D都市モデルデータ、および付随する属性情報を活用して、避難所の最適配置を学習するAIエージェントを訓練します。AIエージェントは、都市内の避難所候補となっている建物の内、「避難者の位置分布や数」「避難所の場所や収容人数」に基づいて、どこを避難所とすれば避難完了率（制限時間内に避難できた人数）を最大化できるかを学習します。

## 2. プロジェクトの作成

### 2-1. Unityプロジェクトの作成
![alt text](image.png)
まずはじめに、Unity Hubを起動し、新規プロジェクトを作成します。プロジェクト名は何でも良いですが、ここでは「EvacuationSimulatorRL」とし、テンプレートは「3D」を選択します。

また、使用するUnityのバージョンですが 本チュートリアル撮影時点でLTS版の`2022.3.4f1`を使用します。
Editor Versionの欄からバージョンを選択してください。
もしここに、エディタのバージョンがない場合は、(Unityのダウンロードアーカイブサイト)[https://unity.com/ja/releases/editor/archive]から該当するエディタのバージョンを選択して、ダウンロードしてください。

### 2-2. パッケージのインストール
プロジェクトの作成が完了したら、必要なパッケージのインストールを行います。

必要なパッケージは３つあります。
1. Newtonsoft.json
   - PLATEAUの属性情報はJSON形式で提供されているため、JSON情報のシリアライズとデシリアライズを行うためのライブラリです。
2. ML-Agents Release 21版
3. PLATEAU SDK for Unity Ver.2.3.2
   
まずは、これらのパッケージをインストールしていきます。
エディタ上部のツールバーから`「Window」→「Package Manager」`を選択します。

次に、`「+」→「Add package from git URL」`を選択し、以下のURLを入力してください。
```
https://github.com/jilleJr/Newtonsoft.Json-for-Unity.git
```
インストールが完了したら、次にPLATEAU SDK For Unityをインストールします。今回はgitのURL指定で導入していきます。
先ほどと、同様に、`「+」→「Add package from git URL」`を選択し、以下のURLを入力してください。
```
https://github.com/Project-PLATEAU/PLATEAU-SDK-for-Unity.git#v2.3.2
```

次に、強化学習で使うML-Agentsをインストールしていきます。こちらは、Unity側で動作するパッケージとPython側で動作するパッケージの２つインストールする必要があります。

まずは、Unity側で動作するパッケージをインストールしていきます。
今回はML-Agentsのrelease 21版を利用するので、その(リリースページ)[https://github.com/Unity-Technologies/ml-agents/releases/tag/release_21]へアクセスしてください。

リリースページにアクセスしたら、下のAssetsにある`「Source Code (zip)」`をダウンロードして
、プロジェクトのルートディレクトリに解凍してください。
![alt text](image-1.png)

解答したら、先ほどと同じように,`PackageManager`を開き、`「＋」→「Add package from disk」`を選択し、先ほど解凍したフォルダの中にある`「com.unity.ml-agents/package.json」`と`「com.unity.ml-agents.extensions/package.json」`を選択してください。
これで、Unity側パッケージのインストールが完了しました。

※環境によってはインストール操作後にエディタログにエラーが表示され、パッケージが正しくインストールされない場合があります。その場合は、一度プロジェクトを閉じて再度起動すれば正しくインストールされます。

次に、Python側の環境構築とML-Agentsをインストールしていきます。
mlagentsでAIを訓練させるには、Pytorchの環境が必要になりますのでそれを整えていきます。
また、利用するML-Agentsのバージョンによって必要となるPythonのバージョンが異なりますので、リリースページに記載されているPythonのバージョンを確認するようにしてください。
Pythonのバージョンを切り替えられるツール（pyenvやrye）などを使用して環境構築することをお勧めします。

ここでは、すでにPythonの環境が整っていることを前提に、仮想環境として標準提供されている`venv`を利用した環境構築を説明します。
まずプロジェクトのルートでターミナルを開き、以下のコマンドを入力して仮想環境を作成してください。
```shell
python -m venv .venv
```
次に、仮想環境を有効化します。これはOSによりコマンドが少し異なるので、以下のコマンドを参考にしてください。
```shell
# Windows
.venv\Scripts\activate
# Mac
source .venv/bin/activate
```
プロンプトの先頭に``(.venv)``と表示されれば、仮想環境の有効化に成功しているので、次の手順へ進みます。
ML-AgentsのPythonパッケージをインストールしていきます。以下のコマンドを入力してください。
今回は、ML-Agentsの1.0.0をインストールします。
```shell
pip install mlagents==1.0.0
```
これには少し時間がかかります。
<!--protobuf等の動作に問題がある場合は、その旨説明し修正版インストール-->

#### GPUを利用する場合（NVIDIA GPU向け）
ML-Agentsは学習時や推論時にGPUを利用することができます。これは多くのケースでCPUで学習や推論を行うよりも高速に動作することがあります。
CUDAに対応しているNVIDIAのGPUをお持ちの方は、CUDA版Pytorchを別途インストールすることでGPUを利用することができます。
<!--本編とは関係ないので一旦割愛。-->

以上で実装の環境構築は完了です。次のステップに進みます。

## 3. 都市モデルのインポート
PLATEAU SDK for Unityを利用して、PLATEAUの都市モデルデータをUnityにインポートしていきます。

使用する都市はどれでも良いですが、今回はLOD2に対応している横須賀市のモデルを利用します。
上部のメニューバーから`「PLATEAU」→「PLATEAU SDK」`を選択しモデルインポート設定の画面を開きます。

![alt text](image-3.png)

モデルデータのインポート方法は任意ですが、ここではサーバーからインポートする方法を選択します。

<!--TODO:モデルインポート設定の説明-->

インポートが完了したら、シーンビューに都市モデルが表示されることを確認してください。

完了したら、インスペクターから環境全体を管理するため、空のGameObjectを作成し、名前を`Field`としておきます。
この`Field`に、都市モデル全体を子要素として追加しておきます。

## 4. 環境全体を制御するプログラムの作成
次に、この`Field`に対して、シミュレーション環境全体を制御するプログラムを作成していきます。

Projectビュー上で、新規でC#スクリプトを作成し、名前を`ShelterEnvManager`としておきます。
エディタでこのファイルを開いて、以下のコードを記述してください。
- `ShelterEnvManager.cs`
```csharp
/**必要な名前空間の参照*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using TMPro;
using PLATEAU.CityInfo;
using PLATEAU.Util;
using Newtonsoft.Json;

/// <summary>
/// シミュレータ環境全般の制御を行うクラス
/// </summary>
public class EnvManager : MonoBehaviour {
    /**シミュレーションモードの選択を定義*/
    public enum SimulateMode {
        Train, // モデル訓練
        Inference // モデル推論
    }

    public enum SpawnMode {
        Random, // 一定の範囲内でランダムに出現
        Custom, // 自身でスポーン位置・範囲を設定
    }

    [Header("Environment Settings")]
    public SimulateMode Mode = SimulateMode.Train; 
    public SpawnMode EvacSpawnMode = SpawnMode.Random; 
    public float TimeScale = 1.0f; // 推論時のシミュレーションの時間スケール
    /// <summary>
    /// 生成する避難者の人数に合わせて避難所の収容人数をスケーリングします.
    /// </summary>
    /// <example>
    /// スケーリング例:
    /// <list type="bullet">
    /// <item>
    /// <description>1.0f: 通常 → 収容人数算出式に合わせて避難所の収容人数を設定</description>
    /// </item>
    /// <item>
    /// <description>0.5f: 避難者の人数が半分 → 避難所の収容人数も半分</description>
    /// </item>
    /// </list>
    /// </example>
    public float AccSimulateScale = 1.0f; 
    public float MaxSeconds = 60.0f; // シミュレーションの最大時間（秒）
    public int SpawnEvacueeSize;
    public GameObject SpawnEvacueePref; // 避難者のプレハブ
    public float SpawnRadius = 10f; // スポーンエリアの半径
    public Vector3 spawnCenter = Vector3.zero; // スポーンエリアの中心位置

    public GameObject AgentObj;
    public ShelterManagementAgent Agent;

    [Header("Objects")]
    [System.NonSerialized]
    public List<GameObject> Evacuees; // 避難者のリスト
    [System.NonSerialized]
    public List<GameObject> CurrentShelters; // 現在のアクティブな避難所のリスト
    public List<GameObject> Shelters; // 全避難所のリスト

    [Header("UI Elements")]
    public TextMeshProUGUI stepCounter;

    // Event Listeners
    public delegate void EndEpisodeHandler(float evacueeRate);
    public EndEpisodeHandler OnEndEpisode;
    public delegate void StartEpisodeHandler();
    public StartEpisodeHandler OnStartEpisode;
    [Header("Parameters")]
    public float EvacuationRate; // 全体の避難率
    public bool EnableEnv = false; // 環境の準備が完了したか否か（利用不可の場合はfalse）
    private int currentStep;
    private float currentTimeSec;

    void Start() {
        if(Mode == SimulateMode.Inference) {
            Time.timeScale = TimeScale; // 推論時のみシミュレーションの時間スケールを設定
        }

        if(AccSimulateScale > 1.0f) {
            Debug.LogError("AccSimulateScale is greater than 1.0f. Please set the value between 0.0f and 1.0f.");
        }

        NavMesh.pathfindingIterationsPerFrame = 1000000; // パス検索の上限値を設定

        Agent = AgentObj.GetComponent<ShelterManagementAgent>();
        Evacuees = new List<GameObject>(); // 避難者のリストを初期化
        CurrentShelters = new List<GameObject>(); // 避難所のリストを初期化
        Shelters = new List<GameObject>(); // 避難所のリストを初期化
        currentStep = Agent.StepCount;

        // 避難所登録
        Shelters = new List<GameObject>(GameObject.FindGameObjectsWithTag("Shelter"));
        // 固定値の避難所を追加
        GameObject[] constSheleters = GameObject.FindGameObjectsWithTag("ConstShelter");
        foreach (var shelter in constSheleters) {
            Shelters.Add(shelter);
        }
        // コンポーネントの初期化
        foreach (var shelter in Shelters) {
            if(shelter.GetComponent<Shelter>() == null) {
                Shelter tower = shelter.AddComponent<Shelter>();
                tower.uuid = System.Guid.NewGuid().ToString();
                tower.MaxCapacity = GetAccSize(shelter);
                tower.NowAccCount = 0;
            }
        }

        /** エピソード終了時の処理*/
        OnEndEpisode += (float evacuateRate) => {
            currentTimeSec = 0; // 時間をリセット
            Agent.SetReward(evacuateRate * 100); // 避難完了率を報酬を設定
            Agent.EndEpisode(); // エピソード終了
        };
    }

    void OnDrawGizmos() {
        if(EvacSpawnMode == SpawnMode.Random) {
            Gizmos.color = Color.red;
            DrawWireCircle(spawnCenter, SpawnRadius);
        }
    }

    void FixedUpdate() {
        currentTimeSec += Time.deltaTime;
        EvacuationRate = GetCurrentEvacueeRate();
        UpdateUI();
        if (currentTimeSec >= MaxSeconds) { // 制限時間の判定
            OnEndEpisode?.Invoke(EvacuationRate); // 制限時間を超えた場合、エピソード終了のイベントを発火
        }
    }

    /// <summary>
    /// エピソード開始時の初期化処理
    /// この関数はエージェントのイベント関数から参照されます 
    /// </summary>
    public void OnEpisodeBegin() {
        EnableEnv = false;
        Dispose();
        Create();
        OnStartEpisode?.Invoke();
        EnableEnv = true;
    }

    /// <summary>
    /// 環境をリセット,破棄をする関数。
    /// - 避難者のクリア
    /// - 避難所のクリア
    /// </summary>
    public void Dispose() {
        foreach (var evacuee in Evacuees) {
            Destroy(evacuee);
        }
        Evacuees = new List<GameObject>(); // 新しいリストを作成
        CurrentShelters = new List<GameObject>(); // 新しいリストを作成
    }

    /// <summary>
    /// 環境の生成を行う関数.
    /// - 避難者のスポーン 処理
    /// </summary>
    public void Create() {
        // 避難者のスポーン
        if(EvacSpawnMode == SpawnMode.Custom) {
            GameObject[] spawnPoints = GameObject.FindGameObjectsWithTag("SpawnPos");
            foreach (var spawnPoint in spawnPoints) {
                var point = spawnPoint.GetComponent<EvacueeSpawnPoint>();
                float radius = point.SpawnRadius;
                Vector3 spawnCenter = spawnPoint.transform.position;
                Vector3 spawnPos = GetRandomPositionOnNavMesh(radius, spawnCenter);
                for (int i = 0; i < point.SpawnSize; i++) {
                    SpawnEvacuee(spawnPos);
                }
            }
        } else {
            for (int i = 0; i < SpawnEvacueeSize; i++) {
                Vector3 spawnPos = GetRandomPositionOnNavMesh(SpawnRadius, spawnCenter);
                if (spawnPos != Vector3.zero) {
                    SpawnEvacuee(spawnPos);
                }
            }
        }
    }

    /// <summary>
    /// 避難者１体を生成、登録する関数
    /// </summary>
    /// <param name="spawnPos"></param>
    private void SpawnEvacuee(Vector3 spawnPos) {
        GameObject evacuee = Instantiate(SpawnEvacueePref, spawnPos, Quaternion.identity, transform);
        evacuee.tag = "Evacuee";
        Evacuees.Add(evacuee);
    }

    /// <summary>
    /// 範囲内のナビメッシュ上の任意の座標を取得する。
    /// </summary>
    /// <returns>ランダムなナビメッシュ上の座標 or Vector3.zero</returns>
    private static Vector3 GetRandomPositionOnNavMesh(float radius, Vector3 center) {
        Vector3 randomDirection = Random.insideUnitSphere * radius; // 半径内のランダムな位置を取得
        randomDirection += center; // 中心位置を加算
        NavMeshHit hit;
        if (NavMesh.SamplePosition(randomDirection, out hit, radius, NavMesh.AllAreas)) {
            return hit.position;
        }
        return Vector3.zero; // ナビメッシュが見つからなかった場合
    }

    private void UpdateUI() {
        stepCounter.text = $"Remain Seconds : {MaxSeconds - currentTimeSec:F2}";
    }

    /// <summary>
    /// 現在の避難完了率を取得する
    /// </summary>
    /// <returns>現在の避難完了率: 0～1</returns>
    private float GetCurrentEvacueeRate() {
        int evacueeSize = Evacuees.Count;
        int evacuatedSize = 0;
        foreach (var evacuee in Evacuees) {
            if (!evacuee.activeSelf) {
                evacuatedSize++;
            }
        }
        return (float)evacuatedSize / evacueeSize;
    }



    /// <summary>
    /// 避難者のランダムスポーン範囲を描画する
    /// </summary>
    private static void DrawWireCircle(Vector3 center, float radius, int segments = 36) {
        float angle = 0f;
        float angleStep = 360f / segments;

        Vector3 prevPoint = center + new Vector3(radius, 0, 0); // 初期点

        for (int i = 1; i <= segments; i++) {
            angle += angleStep;
            float rad = Mathf.Deg2Rad * angle;

            Vector3 newPoint = center + new Vector3(Mathf.Cos(rad) * radius, 5, Mathf.Sin(rad) * radius);
            Gizmos.DrawLine(prevPoint, newPoint);

            prevPoint = newPoint; // 次の線を描画するために現在の点を更新
        }
    }


    /// <summary>
    /// 属性情報から避難所の収容人数を取得する
    /// 【計算式】
    /// 収容可能人数＝ 床総面積㎡×0.8÷1.65㎡
    /// ※出典：https://manboukama.ldblog.jp/archives/50540532.html
    /// </summary>
    /// <param name="shelterBldg">避難所のGameObject</param>
    /// <returns>避難所の収容人数(設定パラメータによりスケーリングされます)</returns>
    private int GetAccSize(GameObject shelterBldg) {
        double? totalFloorSize = null;
        // PLATEAU City Objectから、建物の高さを取得し、避難所の収容人数を動的に設定する
        var cityObjectGroup = shelterBldg.GetComponent<PLATEAUCityObjectGroup>();
        var rootCityObject = cityObjectGroup.CityObjects.rootCityObjects[0];

        // Newtonsoft.Jsonを使用して、CityObjectの属性情報クラスにデシリアライズして取得
        var cityObjectJsonStr = JsonConvert.SerializeObject(rootCityObject);
        var attributes = JsonConvert.DeserializeObject<RootObject>(cityObjectJsonStr).Attributes;
        // 属性値リストを巡回し、床総面積から収容人数を算出
        foreach(var attribute in attributes) {
            if(attribute.Key == "uro:buildingDetailAttribute") {
                foreach(var uroAttr in attribute.AttributeSetValue) { 
                    if(uroAttr.Key == "uro:totalFloorArea") {
                        if(double.TryParse(uroAttr.Value.ToString(), out double parsedValue)) {
                            totalFloorSize = parsedValue;
                        }
                    }
                    // 以下必要があれば、他の属性情報を取得する処理を追加することもできます。
                }
            }
        }

        // 結果が取得できなかった場合は0を返す
        if(totalFloorSize == null) {
            Debug.LogError("Failed to get the total floor size of the shelter building.");
            return 0;
        } else {
            // 収容可能人数＝総面積×0.8÷1.65㎡とする
            return (int)((totalFloorSize * 0.8 / 1.65) * AccSimulateScale);
        }
    }
}

```
作成が終わった保存をして、先ほど作成した`Field`オブジェクトにアタッチしてください。

コンパイル後ログにエラーがでますが、まだまだ必要なプログラムが足りていないだけなので、気にせず次のステップに進みます。

### 4-1. PLATEAUの属性情報の型定義ファイルを作成する。
次に、PLATEAUの属性情報を取得するための型定義ファイルを作成します。

先ほど作成した`ShelterEnvManager.cs`で、避難所の収容人数の算出に、PLATEAUの建物オブジェクトの属性情報の１つである「建物の床総面積」を使用しています。この情報を取得し、C#でクラスにデシリアライズして処理する（生データはすべて文字列なため非常に扱いにくい）ために、属性情報が記述されているJSONデータの型定義ファイルを作成します。

Projectビュー上で、新規でC#スクリプトを作成し、名前を`CityObjectTypes.cs`としておきます。
エディタでこのファイルを開いて、以下のコードを記述してください。
- `CityObjectTypes.cs`
```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

public class AttributeValue
{
    public string Key { get; set; }
    public string Type { get; set; }

    private object value;

    [JsonProperty("value")]
    public object Value
    {
        get => Type == "AttributeSet" ? AttributeSetValue : value;
        set
        {
            if (Type == "AttributeSet" && value is JArray jArray)
            {
                // NewTonsoftを使い、JSON配列をList<AttributeValue>に変換
                AttributeSetValue = jArray.ToObject<List<AttributeValue>>();
            }
            else
            {
                this.value = value;
            }
        }
    }

    // "type": "AttributeSet"の場合にデシリアライズされるプロパティ
    [JsonIgnore] // このプロパティはJSONに含めないというフラグ
    public List<AttributeValue> AttributeSetValue { get; private set; }
}

public class RootObject
{
    public string GmlID { get; set; }
    public List<int> CityObjectIndex { get; set; }
    public string CityObjectType { get; set; }
    public List<AttributeValue> Attributes { get; set; }
}
```

作成が終わったら保存してください。

## 5. 避難者キャラクターの作成

## 6. 避難所の作成と設定

## 7. ナビゲーションメッシュの`tran`への敷設

## 8. AIエージェントの作成

## 9. シミュレーション設定

## 10. 学習の実行とモデル作成

## 11. モデルの分析

## 12. モデルを使った推論シミュレーション





